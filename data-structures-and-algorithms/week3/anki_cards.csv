"**Week 3: Merge Two Sorted Lists** - Core Concept","Combine two sorted linked lists into a single sorted linked list."
"**Week 3: Merge Lists** - JS `ListNode` Class","```js\nclass ListNode {\n  constructor(val, next = null) {\n    this.val = val; // Node's value\n    this.next = next; // Reference to the next node\n  }\n}```"
"**Week 3: Merge Lists** - JS `this` Keyword","Inside a class method or constructor, `this` refers to the *instance* of the object being operated on (e.g., `this.val` accesses the value of the specific node instance)."
"**Week 3: Merge Lists** - JS `.next` Property","The pointer in a `ListNode` that links it to the subsequent node in the list. `null` if it's the last node."
"**Week 3: Merge Lists** - Iterative Pattern","1. Create `dummy = new ListNode(-1)` and `current = dummy`. <br> 2. `while (list1 && list2)`: <br>    If `list1.val <= list2.val`, `current.next = list1`, `list1 = list1.next`. <br>    Else, `current.next = list2`, `list2 = list2.next`. <br>    `current = current.next`. <br> 3. Append remaining list: `current.next = list1 || list2;` <br> 4. Return `dummy.next`."
"**Week 3: Merge Lists** - Recursive Pattern","1. **Base Cases:** If `!list1` return `list2`; if `!list2` return `list1`. <br> 2. **Recursive Step:** <br>    If `list1.val <= list2.val`: `list1.next = mergeTwoLists(list1.next, list2); return list1;` <br>    Else: `list2.next = mergeTwoLists(list1, list2.next); return list2;`"
"**Week 3: Merge Lists** - Time Complexity (Iterative & Recursive)","O(n + m) - We need to visit every node in both lists (length n and m)."
"**Week 3: Merge Lists** - Space Complexity (Iterative)","O(1) - Only a few pointers are used regardless of list size."
"**Week 3: Merge Lists** - Space Complexity (Recursive)","O(n + m) - Due to the recursion call stack depth, which in the worst case can equal the total number of nodes." 